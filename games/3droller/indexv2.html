<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>RolloMania</title>
<style>
  :root { --ui: #16ffe2; --danger:#ff2a2a; }
  html,body { height:100%; margin:0; background:#000; overflow:hidden; }
  canvas { display:block; }
  .hud { position:fixed; left:16px; top:12px; color:var(--ui); font:600 18px/1.2 ui-sans-serif,system-ui,Segoe UI,Arial; text-shadow:0 0 8px #0ff6; letter-spacing:.5px }
  .hud .row{margin:.2rem 0}
  #startMenu{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:radial-gradient(ellipse at center, #021 0%, #000 70%); color:#bff;
    font:700 22px/1.3 ui-sans-serif,system-ui,Segoe UI,Arial; text-align:center;
  }
  #card{
    padding:28px 26px; border:1px solid #0ff6; border-radius:16px;
    box-shadow:0 0 24px #0ff4 inset, 0 0 40px #0ff2; background:#0008; max-width:520px
  }
  h1{margin:.2rem 0 1rem; font-size:36px; color:#16ffe2; text-shadow:0 0 16px #0ff8}
  #startBtn{
    margin-top:14px; padding:12px 24px; border:0; border-radius:999px; cursor:pointer;
    color:#001; background:#16ffe2; font-weight:800; letter-spacing:.6px;
    box-shadow:0 0 18px #16ffe2cc, inset 0 0 12px #fff7;
  }
  #gameOver{
    position:fixed; inset:auto 0 20% 0; text-align:center; display:none; color:#f88;
    font:700 24px/1.2 ui-sans-serif,system-ui; text-shadow:0 0 10px #f008
  }
  #controls{
    position:fixed; right:12px; top:12px; color:#8ff; font:500 12px ui-sans-serif; opacity:.9
  }
  #controls label{display:block; margin:.3rem 0}
</style>
</head>
<body>
<div class="hud">
  <div class="row" id="score">SCORE: 0</div>
  <div class="row" id="jumps">JUMPS: 3</div>
  <div class="row" id="streak" style="opacity:.8">x1</div>
</div>

<div id="controls">
  <label>
    Sensitivity
    <input id="sens" type="range" min="0.5" max="2.5" step="0.1" value="1.2">
  </label>
  <label>
    Tilt control
    <input id="tilt" type="checkbox">
  </label>
</div>

<div id="startMenu">
  <div id="card">
    <h1>RolloMania</h1>
    <div>Swipe / drag to steer • Tap with second finger (or Space) to jump.<br/>
      Survive lasers, grab rings, hit neon tunnels for boost. Refill jumps via green shards.</div>
    <button id="startBtn">START</button>
  </div>
</div>

<div id="gameOver">Game Over — press R or Tap START to try again</div>

<!-- ONE module script only -->
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
  window.THREE = THREE; // keep the rest of the code unchanged

  /* ---------------- Core Scene ---------------- */
  const scene = new THREE.Scene();
  scene.fog = null;

  const camera = new THREE.PerspectiveCamera(74, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 7.5, 16);

  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  // color management across versions
  if ('outputColorSpace' in renderer) {
    renderer.outputColorSpace = THREE.SRGBColorSpace;
  } else {
    renderer.outputEncoding = THREE.sRGBEncoding;
  }

  

 // DEBUG helpers (add after floor is added)
scene.add(new THREE.AxesHelper(5));
const test = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshBasicMaterial({ color: 0xff00ff })
);
test.position.set(0, 2, -2);      // was -10
test.scale.set(2.5, 2.5, 2.5);    // make it chunky
scene.add(test);


  /* ---------------- Materials & Helpers (Tron look) ---------------- */
  const UI = 0x16ffe2, DANGER=0xff2a2a, GOLD=0xffe06b, SHARD=0x30ff6d;
  const neon = (hex, emissive=hex, inten=.9) => new THREE.MeshPhongMaterial({
    color: hex, emissive, emissiveIntensity:inten, shininess: 80, specular: hex
  });
  const matte = hex => new THREE.MeshBasicMaterial({ color: hex });

  /* Glowing grid floor */
  {
  const grid = new THREE.GridHelper(40, 40, UI, UI);
grid.material.opacity = 0.9;       // brighter
grid.material.transparent = true;
grid.position.set(0, 0, -4);       // put it in front of the camera
scene.add(grid);

  }
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 2000), matte(0x020607));
  floor.rotation.x = -Math.PI/2; floor.position.z = -900; scene.add(floor);

  /* Neon tunnel frames */
  const frameGeo = new THREE.BoxGeometry(20, 12, .25);
  for (let i=0;i<26;i++){
    const g = new THREE.Mesh(frameGeo, neon(UI, UI, 1.0));
    g.position.set(0,6,-i*30-20);
    scene.add(g);
  }

  /* Side walls (Matrix glyph feel) */
  function makeGlyphMat(){
    const c = document.createElement('canvas'); c.width=128; c.height=512;
    const ctx = c.getContext('2d');
    ctx.fillStyle='#000'; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle='#0d3'; ctx.globalAlpha=.22;
    for(let y=0;y<c.height;y+=18){ ctx.font='12px monospace'; ctx.fillText('01'.repeat(8), 6, y+12); }
    const tex = new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(2,8);
    return new THREE.MeshBasicMaterial({ map:tex, color:0x001f12, transparent:true });
  }
  const wallMat = makeGlyphMat();
  const wallL = new THREE.Mesh(new THREE.PlaneGeometry(2000, 20), wallMat); wallL.rotation.y=Math.PI/2; wallL.position.set(-10,6,-900); scene.add(wallL);
  const wallR = new THREE.Mesh(new THREE.PlaneGeometry(2000, 20), wallMat.clone()); wallR.rotation.y=-Math.PI/2; wallR.position.set(10,6,-900); scene.add(wallR);

  /* Player ball (lower poly for mobile) */
const ball = new THREE.Mesh(
  new THREE.SphereGeometry(1, 32, 32),
  new THREE.MeshBasicMaterial({ color: 0x00ff88 })
);
scene.add(ball); // <-- add this
camera.lookAt(0, 1, -10);   // look where the test cube is
renderer.setClearColor(0x000000, 1);  // explicit background
renderer.render(scene, camera);       // draw once before loop
console.log('THREE rev', THREE.REVISION);
console.log('Canvas size', renderer.domElement.width, renderer.domElement.height, 'DPR', devicePixelRatio);
const gl = renderer.getContext();
console.log('WebGL version', gl.getParameter(gl.VERSION));
console.log('Renderer', gl.getParameter(gl.RENDERER));
console.log('Scene children', scene.children.length);



  /* Trail */
  const trailGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
  const trail = new THREE.Line(trailGeom, new THREE.LineBasicMaterial({ color:UI, transparent:true, opacity:.6 }));
  scene.add(trail);

  /* ---------------- Game State ---------------- */
  let running=false, over=false;
  let score=0, jumps=3, streak=1, targetZOffset=0, zOffset=0;
  let forwardBase=9, forward=9, boostTimer=0;
  const maxX=8.8, minZOffset=-3.0, maxZOffset=3.0;

  const scoreEl = document.getElementById('score');
  const jumpsEl = document.getElementById('jumps');
  const streakEl= document.getElementById('streak');
  const startMenu = document.getElementById('startMenu');
  const startBtn = document.getElementById('startBtn');
  const sensInput= document.getElementById('sens');
  const tiltChk  = document.getElementById('tilt');
  const gameOverEl = document.getElementById('gameOver');

  // Ask for iOS tilt permissions when checkbox is turned on
  tiltChk.addEventListener('change', async () => {
    if (!tiltChk.checked) return;
    const DME = window.DeviceMotionEvent;
    const DOE = window.DeviceOrientationEvent;
    if (DME && typeof DME.requestPermission === 'function') { try { await DME.requestPermission(); } catch {} }
    if (DOE && typeof DOE.requestPermission === 'function') { try { await DOE.requestPermission(); } catch {} }
  });

  /* ---------------- Inputs ---------------- */
  const keys = {};
  addEventListener('keydown',e=>{ keys[e.code]=true; if(e.code==='Space') attemptJump(); if(over && e.code==='KeyR') restart(); });
  addEventListener('keyup',  e=>{ keys[e.code]=false; });
  let touchActive=false, lastTouch=null;
  addEventListener('touchstart', e=>{ touchActive=true; lastTouch = {x:e.touches[0].clientX, y:e.touches[0].clientY}; });
  addEventListener('touchmove', e=>{
    if(!touchActive) return;
    const t=e.touches[0]; const dx=t.clientX-lastTouch.x; const dy=t.clientY-lastTouch.y;
    steer(dx, dy);
    lastTouch={x:t.clientX, y:t.clientY};
  });
  addEventListener('touchend', e=>{ touchActive=false; lastTouch=null; });

  function steer(dx,dy){
    const sens = parseFloat(sensInput.value);
    ball.position.x += (dx/innerWidth)*20*sens;
    ball.position.x = Math.max(-maxX, Math.min(maxX, ball.position.x));
    targetZOffset -= (dy/innerHeight)*6*sens*0.6;
    targetZOffset = Math.max(minZOffset, Math.min(maxZOffset, targetZOffset));
  }
  function attemptJump(){
    if(jumps>0 && ball.position.y<=1.02){
      jumps--; jumpsEl.textContent='JUMPS: '+jumps; vy = 7.6;
    }
  }

  /* Optional tilt */
  let tiltX=0, tiltY=0;
  window.addEventListener('deviceorientation', (ev)=>{
    if(!tiltChk.checked) return;
    const nx = THREE.MathUtils.clamp((ev.gamma || 0)/45, -1, 1);
    const ny = THREE.MathUtils.clamp(((ev.beta || 0) - 45)/45, -1, 1);
    tiltX = nx; tiltY = ny;
  });

  /* ---------------- Entities ---------------- */
  const obstacles=[];   // blocks, lasers, boost rings, refills, coins, quips
  const tmpVec = new THREE.Vector3();

  function spawnBlock(z){
    const m = neon(UI, UI, .35);
    const box = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), m);
    box.position.set((Math.random()-.5)*16, .6, z);
    box.userData.type='block';
    scene.add(box); obstacles.push(box);
  }
  function spawnLaser(z){
    const beam = new THREE.Mesh(new THREE.BoxGeometry(16, .15, .6), neon(DANGER, DANGER, 1.0));
    beam.position.set(0, 1.35 + Math.random()*1.4, z);
    beam.userData.type='laser';
    scene.add(beam); obstacles.push(beam);
  }
  function spawnBoost(z){
    const ring = new THREE.Mesh(new THREE.TorusGeometry(2.2,.12,12,36), neon(UI, UI, .9));
    ring.rotation.x = Math.PI/2;
    ring.position.set((Math.random()-.5)*10, 1.4, z);
    ring.userData.type='boost';
    scene.add(ring); obstacles.push(ring);
  }
  function spawnRefill(z){
    const shard = new THREE.Mesh(new THREE.OctahedronGeometry(.45), neon(SHARD, SHARD, .9));
    shard.position.set((Math.random()-.5)*16, 1.1, z);
    shard.userData.type='refill';
    scene.add(shard); obstacles.push(shard);
  }
  function spawnCoin(z){
    const c = new THREE.Mesh(new THREE.SphereGeometry(.38, 18, 18), neon(GOLD, GOLD, .9));
    c.position.set((Math.random()-.5)*16, 1.1, z);
    c.userData.type='coin';
    scene.add(c); obstacles.push(c);
  }

  let QUIPS=[{text:'Loading…'}];
  function hexToCss(hex){ return '#'+hex.toString(16).padStart(6,'0'); }
  function spawnQuip(z){
    const msg = QUIPS[Math.floor(Math.random()*QUIPS.length)];
    if(!msg) return;
    const plane = textSprite(msg.text, hexToCss(UI), 0.8);
    const left = Math.random()<.5;
    plane.position.set(left?-9.6:9.6, 4+Math.random()*4, z);
    plane.rotation.y = left? Math.PI/2 : -Math.PI/2;
    plane.userData.type='quip';
    scene.add(plane); obstacles.push(plane);
  }
  function textSprite(t, colorCss, scale=1){
    const c = document.createElement('canvas');
    c.width=512; c.height=128; const ctx=c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.font='700 46px ui-sans-serif,system-ui,Segoe UI';
    ctx.fillStyle=colorCss; ctx.shadowColor=colorCss; ctx.shadowBlur=18;
    ctx.fillText(t, 20, 80);
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({ map:tex, transparent:true });
    const spr = new THREE.Sprite(mat); spr.scale.set(8*scale,2*scale,1);
    return spr;
  }

  function seed(){
    let z=-10;
    for(let i=0;i<50;i++){
      z -= 14 + Math.random()*6;
      const roll = Math.random();
      if(roll < .10) spawnLaser(z);
      else if(roll < .18) spawnBoost(z);
      else if(roll < .24) spawnRefill(z);
      else if(roll < .48) spawnBlock(z);
      else if(roll < .70) spawnCoin(z);
      if(Math.random() < .35) spawnQuip(z-1.5);
    }
  }
  seed();

  /* ---------------- Physics & Loop ---------------- */
  let prev=performance.now(), vy=0;
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now - prev)/1000); prev=now;
    if(!running) { renderer.render(scene,camera); return; }

    const sens = parseFloat(sensInput.value);
    const lateral = ( (keys.ArrowRight||keys.KeyD) - (keys.ArrowLeft||keys.KeyA) ) * 12*sens * dt
                  + tiltX * 8*sens * dt;
    const zAdj   = ( (keys.ArrowUp) - (keys.ArrowDown) ) * 6*sens * dt + (-tiltY) * 2*sens * dt;

    ball.position.x += lateral;
    ball.position.x = Math.max(-maxX, Math.min(maxX, ball.position.x));
    targetZOffset += zAdj;
    targetZOffset = THREE.MathUtils.clamp(targetZOffset, minZOffset, maxZOffset);
    zOffset = THREE.MathUtils.damp(zOffset, targetZOffset, 6, dt);

    if(vy!==0 || ball.position.y>1.001){ vy -= 18*dt; ball.position.y += vy*dt; if(ball.position.y<=1){ ball.position.y=1; vy=0; } }

    let spd = forwardBase + score*0.01;
    if(boostTimer>0){ boostTimer-=dt; spd*=1.6; camera.fov = THREE.MathUtils.damp(camera.fov, 82, 3, dt); camera.updateProjectionMatrix();}
    else { camera.fov = THREE.MathUtils.damp(camera.fov, 74, 2, dt); camera.updateProjectionMatrix();}

    forward = THREE.MathUtils.damp(forward, spd, 3, dt);
    score += forward*dt * (1+(streak-1)*0.15);
    scoreEl.textContent = 'SCORE: ' + Math.floor(score);

    camera.position.x = THREE.MathUtils.damp(camera.position.x, ball.position.x, 6, dt);
    camera.position.z = THREE.MathUtils.damp(camera.position.z, ball.position.z + 16 - zOffset*2, 4, dt);
    camera.lookAt(ball.position.x, 1.5, ball.position.z - 6 - zOffset);

    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.position.z += forward*dt;
      if(o.userData.type==='boost' || o.userData.type==='refill' || o.userData.type==='coin') o.rotation.y += 2*dt;

      if(o.position.z > 6){
        scene.remove(o); obstacles.splice(i,1);
        const nz = ball.position.z - 140 - Math.random()*80;
        const roll = Math.random();
        if(roll < .10) spawnLaser(nz);
        else if(roll < .18) spawnBoost(nz);
        else if(roll < .24) spawnRefill(nz);
        else if(roll < .48) spawnBlock(nz);
        else if(roll < .78) spawnCoin(nz);
        if(Math.random() < .38) spawnQuip(nz-1.5);
        continue;
      }

      if(collides(o, ball)){
        const t=o.userData.type;
        if(t==='block' || t==='laser'){ return gameOver(); }
        if(t==='boost'){ boostTimer=3.2; streak=Math.min(5,streak+1); streakEl.textContent='x'+streak; pop(o); }
        if(t==='refill'){ jumps = Math.min(3, jumps+1); jumpsEl.textContent='JUMPS: '+jumps; streak=Math.max(1,streak-1); pop(o); }
        if(t==='coin'){ score += 12; pop(o); }
      }
    }

    trailGeom.setFromPoints([ ball.position.clone(), tmpVec.set(ball.position.x, ball.position.y, ball.position.z+6) ]);
    renderer.render(scene,camera);
  }
  requestAnimationFrame(loop);

  function collides(o, b){
    const dx = Math.abs(o.position.x - b.position.x);
    const dy = Math.abs((o.position.y||0) - b.position.y);
    const dz = Math.abs(o.position.z - b.position.z);
    const type=o.userData.type;

    if(type==='laser'){
      const underBeam = b.position.y < (o.position.y + 0.35);
      return dx<8 && dz<1.2 && underBeam;
    }
    if(type==='boost' || type==='refill' || type==='coin' || type==='quip') return dx<1.3 && dy<1.4 && dz<1.3;
    return dx<1.2 && dy<1.2 && dz<1.2;
  }
  function pop(o){ scene.remove(o); obstacles.splice(obstacles.indexOf(o),1); }

  /* ---------------- Start / Restart ---------------- */
  startBtn.addEventListener('click', ()=>{ if(over) restart(); startMenu.style.display='none'; running=true; });
  function gameOver(){ running=false; over=true; gameOverEl.style.display='block'; }
  function restart(){
    over=false; gameOverEl.style.display='none'; startMenu.style.display='none';
    score=0; jumps=3; streak=1; jumpsEl.textContent='JUMPS: 3'; streakEl.textContent='x1';
    ball.position.set(0,1,0); vy=0; targetZOffset=0; zOffset=0; boostTimer=0; forward=forwardBase=9;
    obstacles.forEach(o=>scene.remove(o)); obstacles.length=0; seed();
    running=true;
  }

  /* ---------------- Wall messages from JSON ---------------- */
  fetch('messages.json?cachebust=' + Date.now()).then(r=>r.json()).then(data=>{
    if(Array.isArray(data.messages)) {
      QUIPS = data.messages
        .filter(m=>m && m.text)
        .map(m=>({text:m.text, rarity:m.rarity||'common', minScore:m.minScore||0}));
    }
  });

  addEventListener('dblclick', attemptJump);
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>
